package rand

import (
	"github.com/ReconfigureIO/fixed"
)

const (
	c    = 256
	mask = c - 1
	r    = 220
	rInv = 18
)

// Modified Ziggurat Algorithm based upon the paper
// "Hardware-Optimized Ziggurat Algorithm for High-Speed Gaussian Random Number Generators"

func fixed26(us <-chan uint32) fixed.Int26_6 {
	return fixed.I26F(0, int32(<-us))
}

// restricted ln from [0, 1) using a 32 lookup table
func log(x fixed.Int26_6) fixed.Int26_6 {
	return [32]fixed.Int26_6{0, 1, 3, 5, 7, 9, 10, 12, 14, 15, 17, 18, 20, 21, 23, 24, 25, 27, 28, 29, 31, 32, 33, 34, 35, 36, 38, 39, 40, 41, 42, 43}[(x>>1)&0x1f]
}

type param struct {
	X     uint8
	F     uint8
	M     int8
	XNext uint8
}

// Normals writes a stream of Int26_6, normally distributed
func (rand Rand) Normals(output chan<- fixed.Int26_6) {
	params := [c]param{{0, 0, 0, 13}, {13, 23, -14, 18}, {18, 17, -18, 21}, {21, 15, -20, 24}, {24, 13, -22, 26}, {26, 12, -24, 28}, {28, 11, -25, 29}, {29, 10, -26, 31}, {31, 10, -27, 32}, {32, 9, -28, 33}, {33, 9, -29, 35}, {35, 9, -30, 36}, {36, 8, -31, 37}, {37, 8, -31, 38}, {38, 8, -32, 39}, {39, 8, -32, 40}, {40, 7, -33, 41}, {41, 7, -33, 42}, {42, 7, -34, 43}, {43, 7, -34, 44}, {44, 7, -34, 44}, {44, 7, -35, 45}, {45, 7, -35, 46}, {46, 6, -35, 47}, {47, 6, -36, 47}, {47, 6, -36, 48}, {48, 6, -36, 49}, {49, 6, -36, 50}, {50, 6, -36, 50}, {50, 6, -37, 51}, {51, 6, -37, 52}, {52, 6, -37, 52}, {52, 6, -37, 53}, {53, 6, -37, 54}, {54, 5, -37, 54}, {54, 5, -37, 55}, {55, 5, -38, 55}, {55, 5, -38, 56}, {56, 5, -38, 57}, {57, 5, -38, 57}, {57, 5, -38, 58}, {58, 5, -38, 58}, {58, 5, -38, 59}, {59, 5, -38, 59}, {59, 5, -38, 60}, {60, 5, -38, 61}, {61, 5, -38, 61}, {61, 5, -38, 62}, {62, 5, -38, 62}, {62, 5, -38, 63}, {63, 5, -38, 63}, {63, 5, -38, 64}, {64, 5, -38, 64}, {64, 4, -38, 65}, {65, 4, -38, 65}, {65, 4, -38, 66}, {66, 4, -38, 66}, {66, 4, -38, 67}, {67, 4, -38, 67}, {67, 4, -38, 68}, {68, 4, -38, 68}, {68, 4, -38, 69}, {69, 4, -38, 69}, {69, 4, -38, 70}, {70, 4, -38, 70}, {70, 4, -38, 71}, {71, 4, -38, 71}, {71, 4, -38, 72}, {72, 4, -38, 72}, {72, 4, -38, 72}, {72, 4, -38, 73}, {73, 4, -38, 73}, {73, 4, -37, 74}, {74, 4, -37, 74}, {74, 4, -37, 75}, {75, 4, -37, 75}, {75, 4, -37, 76}, {76, 4, -37, 76}, {76, 4, -37, 77}, {77, 4, -37, 77}, {77, 4, -37, 77}, {77, 4, -37, 78}, {78, 4, -36, 78}, {78, 4, -36, 79}, {79, 4, -36, 79}, {79, 4, -36, 80}, {80, 4, -36, 80}, {80, 4, -36, 81}, {81, 3, -36, 81}, {81, 3, -36, 81}, {81, 3, -36, 82}, {82, 3, -35, 82}, {82, 3, -35, 83}, {83, 3, -35, 83}, {83, 3, -35, 84}, {84, 3, -35, 84}, {84, 3, -35, 84}, {84, 3, -35, 85}, {85, 3, -35, 85}, {85, 3, -34, 86}, {86, 3, -34, 86}, {86, 3, -34, 87}, {87, 3, -34, 87}, {87, 3, -34, 87}, {87, 3, -34, 88}, {88, 3, -34, 88}, {88, 3, -33, 89}, {89, 3, -33, 89}, {89, 3, -33, 90}, {90, 3, -33, 90}, {90, 3, -33, 90}, {90, 3, -33, 91}, {91, 3, -32, 91}, {91, 3, -32, 92}, {92, 3, -32, 92}, {92, 3, -32, 93}, {93, 3, -32, 93}, {93, 3, -32, 93}, {93, 3, -31, 94}, {94, 3, -31, 94}, {94, 3, -31, 95}, {95, 3, -31, 95}, {95, 3, -31, 96}, {96, 3, -31, 96}, {96, 3, -30, 96}, {96, 3, -30, 97}, {97, 3, -30, 97}, {97, 3, -30, 98}, {98, 3, -30, 98}, {98, 3, -30, 99}, {99, 3, -29, 99}, {99, 3, -29, 100}, {100, 3, -29, 100}, {100, 3, -29, 100}, {100, 3, -29, 101}, {101, 3, -28, 101}, {101, 3, -28, 102}, {102, 3, -28, 102}, {102, 3, -28, 103}, {103, 3, -28, 103}, {103, 3, -27, 103}, {103, 3, -27, 104}, {104, 3, -27, 104}, {104, 3, -27, 105}, {105, 3, -27, 105}, {105, 3, -26, 106}, {106, 3, -26, 106}, {106, 3, -26, 107}, {107, 3, -26, 107}, {107, 3, -26, 108}, {108, 2, -25, 108}, {108, 2, -25, 108}, {108, 2, -25, 109}, {109, 2, -25, 109}, {109, 2, -25, 110}, {110, 2, -24, 110}, {110, 2, -24, 111}, {111, 2, -24, 111}, {111, 2, -24, 112}, {112, 2, -24, 112}, {112, 2, -23, 113}, {113, 2, -23, 113}, {113, 2, -23, 114}, {114, 2, -23, 114}, {114, 2, -22, 115}, {115, 2, -22, 115}, {115, 2, -22, 116}, {116, 2, -22, 116}, {116, 2, -22, 117}, {117, 2, -21, 117}, {117, 2, -21, 118}, {118, 2, -21, 118}, {118, 2, -21, 119}, {119, 2, -20, 119}, {119, 2, -20, 120}, {120, 2, -20, 120}, {120, 2, -20, 121}, {121, 2, -20, 121}, {121, 2, -19, 122}, {122, 2, -19, 122}, {122, 2, -19, 123}, {123, 2, -19, 123}, {123, 2, -18, 124}, {124, 2, -18, 125}, {125, 2, -18, 125}, {125, 2, -18, 126}, {126, 2, -18, 126}, {126, 2, -17, 127}, {127, 2, -17, 127}, {127, 2, -17, 128}, {128, 2, -17, 129}, {129, 2, -16, 129}, {129, 2, -16, 130}, {130, 2, -16, 130}, {130, 2, -16, 131}, {131, 2, -15, 132}, {132, 2, -15, 132}, {132, 2, -15, 133}, {133, 2, -15, 133}, {133, 2, -14, 134}, {134, 2, -14, 135}, {135, 2, -14, 135}, {135, 2, -14, 136}, {136, 2, -13, 137}, {137, 2, -13, 137}, {137, 2, -13, 138}, {138, 2, -13, 139}, {139, 2, -12, 140}, {140, 2, -12, 140}, {140, 2, -12, 141}, {141, 2, -12, 142}, {142, 2, -11, 143}, {143, 2, -11, 143}, {143, 2, -11, 144}, {144, 2, -11, 145}, {145, 2, -10, 146}, {146, 2, -10, 147}, {147, 2, -10, 147}, {147, 2, -10, 148}, {148, 2, -9, 149}, {149, 2, -9, 150}, {150, 2, -9, 151}, {151, 2, -9, 152}, {152, 2, -8, 153}, {153, 2, -8, 154}, {154, 2, -8, 155}, {155, 2, -8, 156}, {156, 2, -7, 157}, {157, 2, -7, 158}, {158, 2, -7, 159}, {159, 2, -7, 160}, {160, 2, -6, 161}, {161, 1, -6, 163}, {163, 1, -6, 164}, {164, 1, -5, 165}, {165, 1, -5, 167}, {167, 1, -5, 168}, {168, 1, -5, 170}, {170, 1, -4, 171}, {171, 1, -4, 173}, {173, 1, -4, 174}, {174, 1, -4, 176}, {176, 1, -3, 178}, {178, 1, -3, 180}, {180, 1, -3, 182}, {182, 1, -3, 185}, {185, 1, -2, 187}, {187, 1, -2, 190}, {190, 1, -2, 193}, {193, 1, -1, 197}, {197, 1, -1, 201}, {201, 1, -1, 206}, {206, 1, -1, 212}, {212, 1, 0, 220}, {220, 1, 0, 233}, {233, 1, 0, 255}}

	uint32s := make(chan uint32, 1)
	go rand.Uint32s(uint32s)

	for {
		keepGoing := true
		var out fixed.Int26_6
		for keepGoing {
			u := int32(<-uint32s)
			// the index we'll use
			i := u & mask
			p := params[i]
			x := fixed.Int26_6(p.X)
			// use u as a fixed point from [0..1)
			t := fixed.I26F(0, int32(uint32(u)>>6))
			z := t.Mul(x)
			if z < fixed.Int26_6(p.XNext) {
				keepGoing = false
				// in bulk, this path should happen very frequently
				if u < 0 {
					out = -z
				} else {
					out = z
				}
			} else if i == 0 {
				// Tail
				var x2 fixed.Int26_6
				for keepGoing {
					t := -log(fixed26(uint32s))
					x2 = t.Mul(rInv)
					y := -log(fixed26(uint32s)) << 1
					if y >= x2.Mul(x2) {
						keepGoing = false
					}
				}
				if u > 0 {
					out = r + x2
				} else {
					out = -r - x2
				}
			} else {
				// wedge

				// This is actually a 22.10
				f := fixed.Int26_6(p.F)
				t := fixed26(uint32s)

				// Resulting fixed point mult will be a (22 + 26).(10 + 6), so we shift 10 and then cast to get us back to 26.6
				y := fixed.Int26_6((uint64(f) * uint64(t)) >> 10)
				m := fixed.Int26_6(p.M)
				if y < m.Mul(z-x) {
					keepGoing = false
					if u < 0 {
						out = -y
					} else {
						out = y
					}
				}
			}

		}
		output <- out
	}

}
